# Breaking Down corr()

In [Breaking Down pollutantmean()](http://bit.ly/2cHyiCl) we describe approaches to solve the first problem within the Johns Hopkins *R Programming* course programming assignment 1. The programming assignment includes three different problems, and this article describes the third part of the assignment, the `corr()` function.

For this part of the assignment students are required to write an R function that builds a vector of correlations, where each element in the output vector is calculated from sensor files having enough valid observations to exceed a threshold value that is passed as an argument to the function.

The following function stub is provided to students.

    corr <- function(directory, threshold = 0) {
         ## 'directory' is a character vector of 1 indicating
         ## the location of the CSV files

         ## 'threshold' is a numeric vector of length 1 indicating
         ## the number of completely observed observations (on all
         ## variables) required to compute the correlation between
         ## nitrate and sulfate, the default is 0

         ## return a numeric vector of correlations
         ## NOTE: do not round the result
    }

This part of the assignment builds on the second function `complete()` in two ways. First, the technique used to calculate complete cases is a necessary element of the third part of the assignement. Second, the output data frame generated by `complete()` can be used within the `corr()` function to decide which correlations to produce.  

## Key assumptions

This problem presents a slightly different challenge than `complete()` because multiple operations against the data are required to process it correctly, whereas `complete()` could be solved with a single reading of the sensor data files. That said, many of the assumptions we listed for `complete()` are also valid for `corr()`.

* Data will be stored in a directory called `specdata`, which is a subdirectory of the R working directory.
* Column (variable) names in the data files are case-sensitive.
* There are 332 sensor files, and therefore, the values of `id` will vary between 1 and 332.
* The only files in the `specdata` directory will be the 332 sensor files.
* There are two types of pollutants stored in the sensor files, `sulfate` and `nitrate`.
* Some of the values of `sulfate` and `nitrate` are missing, and we will need to process these to generate the output vector of correlations.
* The sensor files have data that is separated by commas, and therefore we will need to use an R function that reads these types of files.
* The files are organized by sensor number, and all files within the `specdata` subdirectory have the file type `.csv`. Therefore, we can use the `id` argument to decide which files to read.
* The file names contain leading zeroes (e.g. sensor 1 is stored as `001.csv`), which may be relevant depending on the technique we use to read the data files.

## Potential solutions

As we think about the problem, we can solve it in six basic steps.

1. Read the list of sensor file filenames
2. Initialize an output vector to store the correlations as NULL
2. Use a `for()` loop that iterates over the sensor IDs provided as an argument to the `corr()` function to complete the following: 
3. Read a sensor file, 
4. Check whether the number of complete cases is greater than the threshold value, and if so, 
5. calculate a correlation between `nitrate` and `sulfate`, and use `c() to combine the correlation with the output vector
6. After the `for()` loop completes, return the output vector to the parent environment

Another potential solution makes use of `lapply()` to eliminate the need to build the output vector with a `for()` loop and `c()`. Students interested in implementing this solution should view the Week 3 lectures to learn about `lapply()` before attempting it. 

1. Read the list of sensor file filenames
2. Create a list of data frames by using the list of filenames with `lapply()` and `read.csv()` to load the data from disk.
3. Process each data frame by first checking to see whether the number of complete cases in the data frame exceeds the threshold value, and if so, calculate the correlation between nitrate and sulfate.
4. Consolidate the correlations into a vector and return the vector to the parent environment.

A third potential solution builds on the `complete()` function. This solution looks like:

1. Execute `complete()` on all 332 sensor files, and save the result to a data frame.
2. Subset the data frame to an output data frame containing all sensors with complete cases exceeding the threshold value.
3. Use the `id` column from the subset data frame to re-read the data files, and calculate correlations for these sensors.
4. Return the resulting vector of correlations to the parent environment.

Since the `lapply()` based solution is more efficient than the others, we provide a code stub to illustrate it.

    corr <- function(directory, threshold = 0) {

        ## Obtain the list of sensor file filenames

        ## Read the sensor files into a list() of data frames

        ## Process the list of sensor data frames by calculating
        ## number of complete cases, and if this number exceeds
        ## the threshold value passed to the function, calculate the correlation
        ## between nitrate and sulfate for the sensor

        ## Assemble the calculated correlations into a vector, and
        ## return the vector to the parent environment

    }

## Useful R functions

As we provided with `pollutantmean()` and `complete()`, here is a list of functions that may be helpful for solving this problem.

<table>
<tr><th align="left">Function</th><th align="left">What it does</th></tr>
<tr><td>c()</td><td>Combines the objects passed as arguments into a vector</td></tr>
<tr><td>complete.cases()</td><td>Creates a vector that is TRUE when all columns for a case are non-missing, and FALSE when at least one column has a missing value, NA. Note that the vector returned by this function has one element per row in the data frame passed as an argument to <code>complete.cases()</code></td></tr>
<tr><td>cor()</td><td>Calculates correlations between columns in a data frame</td></tr>
<tr><td>dir()<br>list.files()</td><td>Obtain list of files from the specdata directory</td></tr>
<tr><td>for()</td><td>Loop through a set of inputs so they can be processed in a variety of ways</td></tr>
<tr><td>lapply()</td><td>Process the list of inputs in a vectorized manner, allows one to process data without a <code>for()</code> loop. Note that this is a more advanced R function that is taught during Week 3 of the course. <br><br>Details explaining how to use this function are covered in <a href="http://bit.ly/2qK7tVX">Forms of the Extract Operator: Assignment 1 Concepts</a></td></tr>
<tr><td>paste()<br>paste0()</td><td>Combine <code>directory</code> argument with default directory symbols as an argument to <code>list.files()</code></td></tr>
<tr><td>read.csv()</td><td>Loads the contents of a comma separated values file into a data frame</td></tr>
<tr><td>sum()</td><td>Sums the contents of a vector to a single number</code></td></tr>
<tr><td>unlist()</td><td>Used with <code>lapply()</code> to create a vector from `list()` objects generated by `lapply()`</td></tr>
</table>

*Copyright Len Greski 2020, copying with attribution permitted*
